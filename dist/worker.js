(function () {
    'use strict';

    /**
     * Exposes worker functions.
     *
     * @param functions - Map of name to function
     * @param readyPromise - A promise that must be resolved before any worker function calls
     */
    function expose(functions, readyPromise) {
        self.onmessage = async (msg) => {
            await readyPromise;
            const { name, args, transferableIndices } = msg.data;
            const transferables = [];
            let data;
            try {
                const workerFunction = functions[name];
                if (typeof workerFunction !== 'function') {
                    console.error(`${name} is not an exposed worker function`);
                    self.close();
                    return; // close doesn't immediately kill the worker
                }
                const result = await workerFunction(...args);
                args.forEach((arg, i) => transferableIndices.includes(i) && transferables.push(arg));
                data = { type: 'success', result, transferables };
            }
            catch (error) {
                const { message, name } = error;
                data = {
                    type: 'error',
                    error: {
                        message,
                        name
                    }
                };
            }
            self.postMessage(data, transferables);
        };
    }
    /**
     * Loads wasm generated by emscripten.
     *
     * @param script - The name of js wrapper.
     * @param options - The URL prefix of files if use CDN and function to execute before promise resolved.
     * @returns A promise that is resolved when wasm is loaded.
     */
    function loadWasm(script, options) {
        options = options || {};
        const { url, init } = options;
        return new Promise(resolve => {
            self.Module = {
                onRuntimeInitialized() {
                    init && init();
                    resolve(null);
                },
                locateFile(path, prefix) {
                    return (url || prefix) + path;
                }
            };
            importScripts((url || '') + script);
        });
    }

    const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

    let idbProxyableTypes;
    let cursorAdvanceMethods;
    // This is a function to prevent it throwing up in node environments.
    function getIdbProxyableTypes() {
        return (idbProxyableTypes ||
            (idbProxyableTypes = [
                IDBDatabase,
                IDBObjectStore,
                IDBIndex,
                IDBCursor,
                IDBTransaction,
            ]));
    }
    // This is a function to prevent it throwing up in node environments.
    function getCursorAdvanceMethods() {
        return (cursorAdvanceMethods ||
            (cursorAdvanceMethods = [
                IDBCursor.prototype.advance,
                IDBCursor.prototype.continue,
                IDBCursor.prototype.continuePrimaryKey,
            ]));
    }
    const cursorRequestMap = new WeakMap();
    const transactionDoneMap = new WeakMap();
    const transactionStoreNamesMap = new WeakMap();
    const transformCache = new WeakMap();
    const reverseTransformCache = new WeakMap();
    function promisifyRequest(request) {
        const promise = new Promise((resolve, reject) => {
            const unlisten = () => {
                request.removeEventListener('success', success);
                request.removeEventListener('error', error);
            };
            const success = () => {
                resolve(wrap(request.result));
                unlisten();
            };
            const error = () => {
                reject(request.error);
                unlisten();
            };
            request.addEventListener('success', success);
            request.addEventListener('error', error);
        });
        promise
            .then((value) => {
            // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
            // (see wrapFunction).
            if (value instanceof IDBCursor) {
                cursorRequestMap.set(value, request);
            }
            // Catching to avoid "Uncaught Promise exceptions"
        })
            .catch(() => { });
        // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
        // is because we create many promises from a single IDBRequest.
        reverseTransformCache.set(promise, request);
        return promise;
    }
    function cacheDonePromiseForTransaction(tx) {
        // Early bail if we've already created a done promise for this transaction.
        if (transactionDoneMap.has(tx))
            return;
        const done = new Promise((resolve, reject) => {
            const unlisten = () => {
                tx.removeEventListener('complete', complete);
                tx.removeEventListener('error', error);
                tx.removeEventListener('abort', error);
            };
            const complete = () => {
                resolve();
                unlisten();
            };
            const error = () => {
                reject(tx.error || new DOMException('AbortError', 'AbortError'));
                unlisten();
            };
            tx.addEventListener('complete', complete);
            tx.addEventListener('error', error);
            tx.addEventListener('abort', error);
        });
        // Cache it for later retrieval.
        transactionDoneMap.set(tx, done);
    }
    let idbProxyTraps = {
        get(target, prop, receiver) {
            if (target instanceof IDBTransaction) {
                // Special handling for transaction.done.
                if (prop === 'done')
                    return transactionDoneMap.get(target);
                // Polyfill for objectStoreNames because of Edge.
                if (prop === 'objectStoreNames') {
                    return target.objectStoreNames || transactionStoreNamesMap.get(target);
                }
                // Make tx.store return the only store in the transaction, or undefined if there are many.
                if (prop === 'store') {
                    return receiver.objectStoreNames[1]
                        ? undefined
                        : receiver.objectStore(receiver.objectStoreNames[0]);
                }
            }
            // Else transform whatever we get back.
            return wrap(target[prop]);
        },
        set(target, prop, value) {
            target[prop] = value;
            return true;
        },
        has(target, prop) {
            if (target instanceof IDBTransaction &&
                (prop === 'done' || prop === 'store')) {
                return true;
            }
            return prop in target;
        },
    };
    function replaceTraps(callback) {
        idbProxyTraps = callback(idbProxyTraps);
    }
    function wrapFunction(func) {
        // Due to expected object equality (which is enforced by the caching in `wrap`), we
        // only create one new func per func.
        // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
        if (func === IDBDatabase.prototype.transaction &&
            !('objectStoreNames' in IDBTransaction.prototype)) {
            return function (storeNames, ...args) {
                const tx = func.call(unwrap(this), storeNames, ...args);
                transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
                return wrap(tx);
            };
        }
        // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
        // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
        // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
        // with real promises, so each advance methods returns a new promise for the cursor object, or
        // undefined if the end of the cursor has been reached.
        if (getCursorAdvanceMethods().includes(func)) {
            return function (...args) {
                // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
                // the original object.
                func.apply(unwrap(this), args);
                return wrap(cursorRequestMap.get(this));
            };
        }
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            return wrap(func.apply(unwrap(this), args));
        };
    }
    function transformCachableValue(value) {
        if (typeof value === 'function')
            return wrapFunction(value);
        // This doesn't return, it just creates a 'done' promise for the transaction,
        // which is later returned for transaction.done (see idbObjectHandler).
        if (value instanceof IDBTransaction)
            cacheDonePromiseForTransaction(value);
        if (instanceOfAny(value, getIdbProxyableTypes()))
            return new Proxy(value, idbProxyTraps);
        // Return the same value back if we're not going to transform it.
        return value;
    }
    function wrap(value) {
        // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
        // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
        if (value instanceof IDBRequest)
            return promisifyRequest(value);
        // If we've already transformed this value before, reuse the transformed value.
        // This is faster, but it also provides object equality.
        if (transformCache.has(value))
            return transformCache.get(value);
        const newValue = transformCachableValue(value);
        // Not all types are transformed.
        // These may be primitive types, so they can't be WeakMap keys.
        if (newValue !== value) {
            transformCache.set(value, newValue);
            reverseTransformCache.set(newValue, value);
        }
        return newValue;
    }
    const unwrap = (value) => reverseTransformCache.get(value);

    /**
     * Open a database.
     *
     * @param name Name of the database.
     * @param version Schema version.
     * @param callbacks Additional callbacks.
     */
    function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
        const request = indexedDB.open(name, version);
        const openPromise = wrap(request);
        if (upgrade) {
            request.addEventListener('upgradeneeded', (event) => {
                upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
            });
        }
        if (blocked) {
            request.addEventListener('blocked', (event) => blocked(
            // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
            event.oldVersion, event.newVersion, event));
        }
        openPromise
            .then((db) => {
            if (terminated)
                db.addEventListener('close', () => terminated());
            if (blocking) {
                db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));
            }
        })
            .catch(() => { });
        return openPromise;
    }

    const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
    const writeMethods = ['put', 'add', 'delete', 'clear'];
    const cachedMethods = new Map();
    function getMethod(target, prop) {
        if (!(target instanceof IDBDatabase &&
            !(prop in target) &&
            typeof prop === 'string')) {
            return;
        }
        if (cachedMethods.get(prop))
            return cachedMethods.get(prop);
        const targetFuncName = prop.replace(/FromIndex$/, '');
        const useIndex = prop !== targetFuncName;
        const isWrite = writeMethods.includes(targetFuncName);
        if (
        // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
        !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
            !(isWrite || readMethods.includes(targetFuncName))) {
            return;
        }
        const method = async function (storeName, ...args) {
            // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
            const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
            let target = tx.store;
            if (useIndex)
                target = target.index(args.shift());
            // Must reject if op rejects.
            // If it's a write operation, must reject if tx.done rejects.
            // Must reject with op rejection first.
            // Must resolve with op value.
            // Must handle both promises (no unhandled rejections)
            return (await Promise.all([
                target[targetFuncName](...args),
                isWrite && tx.done,
            ]))[0];
        };
        cachedMethods.set(prop, method);
        return method;
    }
    replaceTraps((oldTraps) => ({
        ...oldTraps,
        get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
        has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
    }));

    var luna_pinyin = [
    	{
    		name: "luna_pinyin.prism.bin",
    		md5: "940de9059d6bc1d257a88890a5e36870"
    	},
    	{
    		name: "luna_pinyin.reverse.bin",
    		md5: "d16701cc9cc16ab74f3b60b336409bf1"
    	},
    	{
    		name: "luna_pinyin.schema.yaml",
    		md5: "06a829c8400679f71411d3f047180d75"
    	},
    	{
    		name: "luna_pinyin.table.bin",
    		md5: "153ea95bab6e4ee20abff0f5dfec6ead"
    	}
    ];
    var luna_pinyin_fluency = [
    	{
    		name: "luna_pinyin_fluency.schema.yaml",
    		md5: "faa464a7af6f57dad5fe618bc54e95da"
    	},
    	"luna_pinyin"
    ];
    var ShanRenMaLTS = [
    	{
    		name: "ShanRenMaLTS.prism.bin",
    		md5: "2e81ddb118c7424eb3f3d4a01b08bf72"
    	},
    	{
    		name: "ShanRenMaLTS.reverse.bin",
    		md5: "15ed69bbdf732c724d8658cda5526bbe"
    	},
    	{
    		name: "ShanRenMaLTS.schema.yaml",
    		md5: "2786cc67ea1fe2e194d1e82e28bd1f4d"
    	},
    	{
    		name: "ShanRenMaLTS.table.bin",
    		md5: "993935d742dc8ce390a336d5f40dba65"
    	}
    ];
    var jyut6ping3 = [
    	{
    		name: "jyut6ping3.prism.bin",
    		md5: "227b54d955a5a0eedd895d2a411ee08d"
    	},
    	{
    		name: "jyut6ping3.reverse.bin",
    		md5: "3acfeffdb3af04c60befd649a57a880c"
    	},
    	{
    		name: "jyut6ping3.schema.yaml",
    		md5: "8b9ef9a3c89279c2ead72fd0e25d4bc4"
    	},
    	{
    		name: "jyut6ping3.table.bin",
    		md5: "254a658e0ab2bbf442a505d25c7c14f6"
    	}
    ];
    var jyut6ping3_ipa = [
    	{
    		name: "jyut6ping3_ipa.prism.bin",
    		md5: "e1ed0b392b279d7768f4135d794591a5"
    	},
    	"jyut6ping3",
    	{
    		name: "jyut6ping3_ipa.schema.yaml",
    		md5: "f20b6f82975b50ac0cc3bf48ad712c64"
    	}
    ];
    var schemaFiles = {
    	ShanRenMaLTS: ShanRenMaLTS
    };

    const HASH = 'hash';
    const CONTENT = 'content';
    const dbPromise = openDB('ime', 1, {
        upgrade(db) {
            db.createObjectStore(HASH);
            db.createObjectStore(CONTENT);
        }
    });
    async function setIME(ime) {
        function getFiles(key) {
            const files = [];
            for (const item of schemaFiles[key]) {
                if (typeof item === 'string') { // root schema_id
                    files.push(...getFiles(item));
                }
                else {
                    files.push(item);
                }
            }
            return files;
        }
        const files = getFiles(ime);
        const db = await dbPromise.catch(() => undefined); // not available in Firefox Private Browsing
        await Promise.all(files.map(async ({ name, md5 }) => {
            const path = `build/${name}`;
            try {
                Module.FS.lookupPath(path);
            }
            catch (e) { // not exists
                const storedHash = await db?.get(HASH, name);
                let ab;
                if (storedHash === md5) {
                    ab = await db.get(CONTENT, name);
                }
                else {
                    const response = await fetch('/ShanRenMaLTS/dist/' + `ime/${name}`);
                    if (!response.ok) {
                        throw new Error(`Fail to download ${name}`);
                    }
                    ab = await response.arrayBuffer();
                    await db?.put(CONTENT, ab, name);
                    await db?.put(HASH, md5, name);
                }
                Module.FS.writeFile(path, new Uint8Array(ab));
            }
        }));
        Module.ccall('set_ime', 'null', ['string'], [ime]);
    }
    const readyPromise = loadWasm('/ShanRenMaLTS/dist/rime.js', {
        url: '',
        init() {
            Module.ccall('init', 'null', [], []);
            Module.FS.mkdir('build');
        }
    }).then(() => setIME(Object.keys(schemaFiles)[0]));
    expose({
        setIME,
        setOption(option, value) {
            return Module.ccall('set_option', 'null', ['string', 'number'], [option, value]);
        },
        process(input) {
            return Module.ccall('process', 'string', ['string'], [input]);
        }
    }, readyPromise);

})();
